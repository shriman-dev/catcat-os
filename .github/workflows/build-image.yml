name: build images
on:
  workflow_call:
  schedule:
    - cron: '05 10 * * *'  # 10:05am UTC everyday
#  pull_request:
#    branches:
#      - main
#  push:
#    branches:
#      - main
#    paths-ignore:
#      - '**/README.md'
#      - '**/build-iso.yml'
#      - '**/create-release.yml'
  workflow_dispatch:

env:
  IMAGE_DESC: "Meow"
  PUSH_IMAGE_REGISTRY: "ghcr.io/${{ github.repository_owner }}"  # do not edit

concurrency:
  group: build-image-${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

jobs:
  build_push:
    name: Build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - IMAGE_NAME: catcat-os
            BASE_IMAGE_NAME: ghcr.io/ublue-os/bazzite-gnome

          - IMAGE_NAME: catcat-os-mi
            BASE_IMAGE_NAME: ghcr.io/ublue-os/silverblue-main

          - IMAGE_NAME: catcat-os-nv
            ALT_TAG: nvidia
            BASE_IMAGE_NAME: ghcr.io/ublue-os/bazzite-gnome-nvidia-open

          - IMAGE_NAME: catcat-os-hh
            BASE_IMAGE_NAME: ghcr.io/ublue-os/bazzite-deck-gnome

#          - IMAGE_NAME: catcat-os-sv
#            BASE_IMAGE_NAME: ghcr.io/ublue-os/ucore-minimal:stable

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v6

      - name: Maximize build space
        uses: ublue-os/remove-unwanted-software@v9

      - name: Mount BTRFS for podman storage
        id: container-storage-action
        uses: ublue-os/container-storage-action@911baca08baf30c8654933e9e9723cb399892140
        # Fallback to the remove-unwanted-software-action if github doesn't allocate enough space
        continue-on-error: true
        with:
          mount-opts: compress-force=zstd:3
          target-dir: /var/lib/containers
#          loopback-free: '1'

      - name: Prepare environment
        id: prepare-environment
        shell: bash
        run: |
          set -ouex pipefail
          pwd
          ls -A1
          lsblk --all -o +FSUSED,FSSIZE,LABEL,FSTYPE
          source ${{ github.workspace }}/ENVAR
          echo "MAJOR_VERSION=${MAJOR_VERSION}" >> $GITHUB_ENV
          echo "DEFAULT_TAG=${DEFAULT_TAG}" >> $GITHUB_ENV
          echo "DATESTAMP=${DATESTAMP}" >> $GITHUB_ENV
          echo "TIMESTAMP=${TIMESTAMP}" >> $GITHUB_ENV
          echo "AHHH_DATE=${AH_DATE}" >> $GITHUB_ENV
          echo "COMMIT_SHA=${GITHUB_SHA}" >> $GITHUB_ENV
          echo "PUSH_IMAGE_REGISTRY=${PUSH_IMAGE_REGISTRY,,}" >> ${GITHUB_ENV}
          if [[ ${{ matrix.BASE_IMAGE_NAME }} =~ "bazzite" ]]; then
              echo "TAG_VER=stable-${MAJOR_VERSION}" >> $GITHUB_ENV
          elif [[ ${{ matrix.BASE_IMAGE_NAME }} =~ "ucore" ]]; then
              echo "TAG_VER=stable" >> $GITHUB_ENV
          else
              echo "TAG_VER=${MAJOR_VERSION}" >> $GITHUB_ENV
          fi

      # Build metadata
      - name: Image Metadata
        uses: docker/metadata-action@v5
        id: metadata
        with:
          tags: |
            type=raw,value=${{ env.DEFAULT_TAG }}
            type=raw,value=${{ env.MAJOR_VERSION }}
            type=raw,value=${{ env.MAJOR_VERSION }}.${{ env.DATESTAMP }}
            type=raw,value=${{ env.MAJOR_VERSION }}.${{ env.DATESTAMP }}.${{ env.TIMESTAMP }}
            type=raw,value={{sha}}
            type=sha,enable=${{ github.event_name == 'pull_request' }}
            type=ref,event=pr
          labels: |
            io.artifacthub.package.readme-url=https://raw.githubusercontent.com/${{ github.repository }}/main/README.md
            org.opencontainers.image.created=${{ env.AHHH_DATE }}
            org.opencontainers.image.description=${{ env.IMAGE_DESC }}
            org.opencontainers.image.title=${{ matrix.IMAGE_NAME }}
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.version=${{ env.MAJOR_VERSION }}.${{ env.DATESTAMP }}.${{ env.TIMESTAMP }}
            containers.bootc=1
          sep-tags: " "
          sep-annotations: " "

      # Build image using Buildah action
      - name: Build Image
        id: build-image
        uses: redhat-actions/buildah-build@v2
        with:
          containerfiles: |
            ./Containerfile
          image: ${{ matrix.IMAGE_NAME }}
          labels: ${{ steps.metadata.outputs.labels }}
          tags: |
            ${{ matrix.ALT_TAG }}
            ${{ steps.metadata.outputs.tags }}
          build-args: |
            BASE_IMAGE_NAME=${{ matrix.BASE_IMAGE_NAME }}
            IMAGE_NAME=${{ matrix.IMAGE_NAME }}
            ALT_TAG=${{ matrix.ALT_TAG }}
            MAJOR_VERSION=${{ env.MAJOR_VERSION }}
            TAG_VER=${{ env.TAG_VER }}
            DATESTAMP=${{ env.DATESTAMP }}
            TIMESTAMP=${{ env.TIMESTAMP }}
            COMMIT_SHA=${{ env.COMMIT_SHA }}
          oci: false


      # Rechunk is a script that we use on Universal Blue to make sure there isnt a single huge layer when your image gets published.
      # This does not make your image faster to download, just provides better resumability and fixes a few errors.
      # Documentation for Rechunk is provided on their github repository at https://github.com/hhd-dev/rechunk
      # You can enable it by uncommenting the following lines
      # - name: Run Rechunker
      #   id: rechunk
      #   uses: ublue-os/legacy-rechunk@a925083d9af7cb04b3e2a6e8c01bfa495f38b710 # v1.0.0
      #   with:
      #     rechunk: 'ghcr.io/ublue-os/legacy-rechunk:v1.0.0-x86_64'
      #     ref: "localhost/${{ matrix.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}"
      #     prev-ref: "${{ env.PUSH_IMAGE_REGISTRY }}/${{ matrix.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}"
      #     skip_compression: false
      #     version: ${{ env.MAJOR_VERSION }}
      #     labels: ${{ steps.metadata.outputs.labels }} # Rechunk strips out all the labels during build, this needs to be reapplied here with newline separator

      # This is necessary so that the podman socket can find the rechunked image on its storage
      # - name: Load in podman and tag
      #   run: |
      #     IMAGE=$(podman pull ${{ steps.rechunk.outputs.ref }})
      #     sudo rm -rf ${{ steps.rechunk.outputs.output }}
      #     for tag in ${{ steps.metadata.outputs.tags }}; do
      #       podman tag ${IMAGE} ${{ matrix.IMAGE_NAME }}:$tag
      #     done

      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push To GHCR
        if: github.event_name != 'pull_request' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        uses: redhat-actions/push-to-registry@v2
        id: push
        env:
          REGISTRY_USER: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ github.token }}
        with:
          registry: ${{ env.PUSH_IMAGE_REGISTRY }}
          image: ${{ matrix.IMAGE_NAME }}
          tags: ${{ steps.metadata.outputs.tags }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}
#          extra-args: |
#            --compression-format=zstd
#            --compression-level=20


      # This section is optional and only needs to be enabled if you plan on distributing
      # your project for others to consume. You will need to create a public and private key
      # using Cosign and save the private key as a repository secret in Github for this workflow
      # to consume. For more details, review the image signing section of the README.
      - name: Install Cosign
        if: github.event_name != 'pull_request' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        uses: sigstore/cosign-installer@v3.10.1

      - name: Sign container image
        if: github.event_name != 'pull_request' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        run: |
          echo "Image Digest: $DIGEST"
          cosign sign -y --key env://COSIGN_PRIVATE_KEY ${IMAGE_FULL}@${DIGEST}
        env:
          IMAGE_FULL: ${{ env.PUSH_IMAGE_REGISTRY }}/${{ matrix.IMAGE_NAME }}
          DIGEST: ${{ steps.push.outputs.digest }}
          COSIGN_EXPERIMENTAL: false
          COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}
